/*
* This script responds to an 'hours' request via email using the toggl api.
* For documentation on how to use this script go to www.github.com/zing321/gmail-toggl-responder
*
* Author: Tobin Thomas
*/

/*------------------------------------------USER-SETTINGS--------------------------------------------*/

var API_DETAILS_URL = 'https://toggl.com/reports/api/v2/details'
var API_TOKEN = '';
var WORKSPACE_ID = '';
var CLIENT_IDS = ''; //seperated by comma
var KEYWORD = 'hours'; //not case sensitive
var CSV_HEADERS = 'Description,Start,End,Duration,,Total Duration';
var MESSAGE_BODY = 'Here are the hours you requested!'

//functions to modify raw entry values
doNothing = function(value){
  return value;
};

dateToString = function(date){
  return date.toString();
};

millisecondsToHMS = function(ms){
  //this function should've been built into JS -_-
  var h = ms / 3600000; //hours
  var m = (h % 1) * 60; //minutes
  var s = (m % 1) * 60; //seconds

  return h.toFixed(0) + ':' + m.toFixed(0) + ':' + s.toFixed(0);
};

//should be in order relative to your CSV_HEADERS
var ENTRY_TO_CSV = {
  'description': doNothing,
  'start': dateToString,
  'end': dateToString,
  'dur': millisecondsToHMS
};

/*------------------------------------------END-USER-SETTINGS------------------------------------------*/

//Date will not parse 'March 19' when fed into new Date('March 19') or Date.parse('March 19').
//This is due to Google using an outdated version of JS
//Thus the below dictionaries are necessary -_-
var FULL_MONTHS = {
  'JANUARY': 0,
  'FEBRUARY': 1,
  'MARCH': 2,
  'APRIL': 3,
  'MAY': 4,
  'JUNE': 5,
  'JULY': 6,
  'AUGUST': 7,
  'SEPTEMBER': 8,
  'OCTOBER': 9,
  'NOVEMBER': 10,
  'DECEMBER': 11
};

var PAR_MONTHS = {
  'JAN': 0,
  'FEB': 2,
  'APR': 3,
  'MAY': 4,
  'JUN': 5,
  'JUL': 6,
  'AUG': 7,
  'SEP': 8,
  'OCT': 9,
  'NOV': 10,
  'DEC': 11
};

//WARNING: changing this after this script has processed emails can cause
//         old emails to resend if there are any unread messages in those threads
var THREAD_LABEL = 'HRespProcessed'

function HoursResponder() {
  var unreadThreads = getUnreadEmailThreads();

  try {
    var hoursThread = findHoursRequest(unreadThreads);
    if(typeof hoursThread === 'undefined')
      throw 'No Threads to process';

    var dateRange = getDateRangeInString(hoursThread.getFirstMessageSubject());
    var timeEntries = requestDetailedReportFromToggl(dateRange);
    var CSVBlob = convertEntriesToCSV(timeEntries);

    CSVBlob.setName('Hours.csv');
    var body = MESSAGE_BODY+'\n\nAuto generated by: www.github.com/zing321/gmail-toggl-responder'
    hoursThread.replyAll(body, {
      'attachments': [CSVBlob]
    });
    hoursThread.markRead();

    if(typeof GmailApp.getUserLabelByName(THREAD_LABEL) === 'undefined')
      GmailApp.createLabel(THREAD_LABEL);
    hoursThread.addLabel(GmailApp.getUserLabelByName(THREAD_LABEL))
  }
  catch(err) {
    Logger.log(err);
  }
}

getUnreadEmailThreads = function(){
  var threads = GmailApp.getInboxThreads();
  var unreadThreads = [];
  threads.forEach(function(thread){
    if(thread.isUnread())
      unreadThreads.push(thread);
  });
  return unreadThreads;
};

//message Thread must only have 1 message
findHoursRequest = function(threads){
  var returnThread;
  var keyword = KEYWORD.toUpperCase();
  threads.forEach(function(thread){
    var subject = thread.getFirstMessageSubject().toUpperCase();
    if(subject.search(keyword) >= 0 && !doesLabelExist(thread.getLabels()))
      returnThread = thread;
  });
  return returnThread;
};

doesLabelExist = function(labels){
  for(var i = 0, j = labels.length; i < j; i++)
  {
    if(labels[i].getName() === THREAD_LABEL)
      return true;
  }
  return false;
};

//WARNING: Will return unexpected dates if date range spans across more than one calander year
//such as DEC 21 to JAN 10, if the current year is 2015 the return dates will be [DEC 21 2015, JAN 10 2015]
getDateRangeInString = function(theString){
  var dates = [];
  var words = theString.split(' ');
  for(var i = 0, j = words.length; i < j; i++)
  {
    if(!isNaN(words[i]))
    {
      var formattedMonth = words[i-1].toUpperCase();
      if(formattedMonth in FULL_MONTHS)
        dates.push(new Date(new Date().getFullYear(), FULL_MONTHS[formattedMonth], parseInt(words[i])));
      else if(formattedMonth in PAR_MONTHS)
        dates.push(new Date(new Date().getFullYear(), PAR_MONTHS[formattedMonth], parseInt(words[i])));
    }
  }
  return dates;
};

requestDetailedReportFromToggl = function(dateRange){
  var authString = 'Basic ' + Utilities.base64Encode(API_TOKEN + ':api_token');
  var url = API_DETAILS_URL +
    '?user_agent=' + 'User:' + Session.getEffectiveUser().getEmail() + ',Dev:github.com/zing321/gmail-toggl-responder' +
    '&workspace_id=' + WORKSPACE_ID +
    '&client_ids=' + CLIENT_IDS +
    '&since=' + dateRange[0].getFullYear() + '-' + (dateRange[0].getMonth() + 1) + '-' + dateRange[0].getDate() +
    '&until=' + dateRange[1].getFullYear() + '-' + (dateRange[1].getMonth() + 1) + '-' + dateRange[1].getDate() +
    '&order_field=date';

  return fetchAllDataAcrossPages(url, authString);
};

//Recursive function to fetch data across multiple pages if any.
//I haven't made a recursive function in years so I decided why not...
fetchAllDataAcrossPages = function(url, authString, page, dataList){
  //defaults if page/dataList params are not provided

  page = typeof page !== 'undefined' ? page : 1;
  dataList = typeof dataList !== 'undefined' ? dataList : [];

  var data = UrlFetchApp.fetch(url + '&page=' + page,{
    'method': 'get',
    'contentType': 'application/json',
    'headers':{
      'Authorization': authString
    }
  });

  var JSONDict = JSON.parse(data);
  dataList = dataList.concat(JSONDict['data']);

  var entriesPerPage = JSONDict['per_page'];
  if(JSONDict['total_count'] - entriesPerPage * page > 0)
    return fetchAllDetailedData(url, authString, page + 1, dataList);
  else
    return dataList;
};

convertEntriesToCSV = function(timeEntries){
  var csv = CSV_HEADERS + '\n';
  for(var i = 0, j = timeEntries.length; i < j; i++)
  {
    if(i === 0)
      csv += createCSVEntryString(timeEntries[i]) + ',' + millisecondsToHMS(getTotalTime(timeEntries)) + '\n';
    else
      csv += createCSVEntryString(timeEntries[i]) + '\n';
  }
  return Utilities.newBlob(csv, 'text/csv');
};

createCSVEntryString = function(entry){
  var EntryString = '';
  for(var key in ENTRY_TO_CSV)
  {
    //Convert raw entry to user provided format
    //Then replace any commas with periods to avoid csv conflict
    EntryString += ENTRY_TO_CSV[key](entry[key]).replace(',','.') + ',';
  }
  return EntryString;
};

getTotalTime = function(timeEntries){
  var totalTime = 0;
  timeEntries.forEach(function(entry){
    totalTime += entry['dur'];
  });
  return totalTime
};
